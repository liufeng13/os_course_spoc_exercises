## 小组思考题
---
(1)(spoc) 请参考lab3_result的代码，思考如何在lab3_results中实现clock算法，并给出你的概要设计方案，可4人一个小组，说明你的方案中clock算法与LRU算法上相比，潜在的性能差异性。并进一说明LRU算法在lab3实现的可能性评价（给出理由）。 

	思路：
	可以基于已经实现的FIFO算法，进行修改，得到Clock算法实现。
	swap.c line 41:
	sm = &swap_manager_fifo;
	引用了FIFO算法的Swap管理器；实现Clock算法之后在此处替换即可。
 
	在swap_fifo.c line 45:
	init_mm函数中，初始化链表时应该首尾相接构造环形链表，并且加上一个指针指向最先调入的页面。
	另外给每一个页表项加上一个访问位，初始置0，访问时可以用比特AND得到或修改访问位的值。
 
	最后在swap_out_victim中，从指针当前位置顺序检查环形链表；
	若访问位是0，则置换该页，指针移动到下一项；若访问位是1，则把访问位置0，
	指针移动到下一项，重复这个过程直到找到可以置换的页面。

	性能：
	Clock是LRU和FIFO的折衷，会考虑过去访问情况，但是不很详细，而且它不动态调整页面在链表中的顺序，
	只做标记。所以它的开销一般比LRU要小，因为LRU详细记录开销太大。对于未被访问的页面，
	Clock退化为LRU，表现一样好，而对于被访问过的页面，Clock不记录准确访问顺序，
	表现比LRU差但是比FIFO好。



(2)(spoc) 理解内存访问的异常。在x86中内存访问会受到段机制和页机制的两层保护，请基于lab3_results的代码（包括lab1的challenge练习实现），请实践并分析出段机制和页机制各种内存非法访问的后果。，可4人一个小组，，找出尽可能多的各种内存访问异常，并在代码中给出实现和测试用例，在执行了测试用例后，ucore能够显示出是出现了哪种异常和尽量详细的错误信息。请在说明文档中指出：某种内存访问异常的原因，硬件的处理过程，以及OS如何处理，是否可以利用做其他有用的事情（比如提供比物理空间更大的虚拟空间）？哪些段异常是否可取消，并用页异常取代？

